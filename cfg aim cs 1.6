
//____________________________________________________
// Counter-Strike Config
// Creators: WAyziq
// Alternate NICK:
// Have Fun and Good Lock!
// Good luck to frags :-h


//_________________________________________


unbindall

@ @
@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ ��������� !
@
@ @

//********
//-Speciale-
//************

bind "ESCAPE" "cancelselect"
bind "TAB" "+showscores"
bind "SHIFT" "+speed"
bind "CTRL" "+duck"
binb "SPACE" "+jump"
bind "ENTER" "+attack"

//********
//-Buy-
//*********
bind "F1" "autobuy"
bind "F2" "rebuy"
bind "F5" "snapshot"
bind "F6" "save quick"
bind "F7" "load quick"
bind "UPARROW" "secammo;primammo"
bind "LEFTARROW" "vesthelm"
bind "DOWNARROW" "flash;hegren;flash"
bind "RIGHTARROW" "defuser"

//********
//-Slots-
//********

bind "1" "slot1"
bind "2" "slot2"
bind "3" "slot3"
bind "4" "slot4"
bind "5" "slot5"
bind "6" "slot6"
bind "7" "slot7"
bind "8" "slot8"
bind "9" "slot9"
bind "0" "slot10"

//********
//-Keyboard-
//*************

bind "q" "lastinv"
bind "w" "+forward"
bind "e" "+use"
bind "r" "+reload"
bind "t" "impulse 201"
bind "y" "messagemode"
bind "u" "messagemode2"
bind "a" "+moveleft"
bind "s" "+back"
bind "d" "+moveright"
bind "f" "impulse 110"
bind "g" "drop"
bind "h" "+commandmenu"
bind "v" "+voicerecord"
bind "x" "radio2"
bind "c" "radio3"
bind "b" "buy"
bind "n" "nightvision"
bind "m" "chooseteam"
bind "p" "say /raNk"


//********
//-Mouse-
//********

bind "MOUSE1" "+attack"
bind "MOUSE2" "+attack2"
bind "MWHEELDOWN" "+jump"
bind "MWHEELUP" "+duck"

//********
//-Other-
//********

bind "`" "toggleconsole"
bind "~" "toggleconsole"
bind "PGDN" "lookdown"
bind "PGUP" "lookup"
bind "[" "say tiMeleFt"
bind "]" "say neXtmAp"
bind "+" "sizeup"
bind "," "buyammo1"
bind "-" "sizedown"
bind "." "buyammo2"
bind "/" "+movedown"

//********
//-KP_BINDS-
//********

bind "KP_END" "say_team PUNE BOMBA...!!!!"
bind "KP_DOWNARROW "say_team In A!!!!!!!!!"
bind "KP_PGDN" "say_team In B!!!!!!!!!"
bind "KP_LEFTARROW" "say_team CE faci baaaa????"
bind "KP_5" "say_team Faceti Rush!!!!!!"
bind "KP_RIGHTARROW" "say_team Need Backup!!! ...."
bind "KP_HOME" "say_team Stanga!!!!!!"
bind "KP_UPARROW" "say_team SpateeeE!!!!"
bind "KP_PGUP" "say_team Dreapta!!!!"


@ @
@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ Aliasuri Speciale !
@
@ @

// _____________
//--------( Count Jump )---------------------------------------
// �������������







// _____________
//--------( AwP SCript )---------------------------------------
// �������������
alias +[G]_AWPskr1pT "+attack; wait; wait; wait; wait; wait; wait;wait; lastinv; wait; wait; wait; lastinv"
alias -[G]_AWPskr1pT "-attack"
bind "mouse4" "+[G]_AWPskr1pT"

// ____________________
//--------( Airaccelerate JUMP )---------------------------------------
// ��������������������
Alias +sjmp "alias _special smp2;smp2;smp2"
alias -sjmp "alias _special"
alias smp2 "+forward;wait;-forward;+back;wait;

back;wait;special;"

bind x "+sjmp"

// _____________
//--------( Walk Script )---------------------------------------
// �������������

alias walk "+speed; alias wr run; echo walking;"
alias run "-speed; alias wr walk; echo running;"
alias wr "walk"
bind "shift" "wr"

// _____________
//--------( For Jumping )---------------------------------------
// �������������

bind w "+forward;developer 1;fps_max 800"
bind a "+moveleft;developer 1;fps_max 800"
bind d "+moveright;developer 1;fps_max 800"

// ________________
// --= ( Bunny H0p ) =--
// ����������������

alias +hop "alias _special @hop;@hop"
alias -hop "alias _special"
alias @hop "special;wait;

bind "space" "+hop"

@ @
@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ Setari !
@
@ @
_cl_autowepswitch "1"
_snd_mixahead "0.1"
ati_npatch "0.0"
ati_subdiv "0.0"
bgmvolume "1.000000"
bottomcolor "6"
brightness "2"
cl_allowdownload "1.0"
cl_allowupload "1.0"
cl_backspeed "999"
cl_cmdbackup "2"
cl_cmdrate "101"
cl_corpsestay "0"
cl_crosshair_color "300 300 300"
cl_crosshair_size "small"
cl_crosshair_translucent "0"
cl_dlmax "128"
cl_download_ingame "1"
cl_dynamiccrosshair "0"
cl_forwardspeed "999"
cl_himodels "0.000000"
cl_idealpitchscale "0.8"
cl_lc "1"
cl_logocolor "#Valve_Orange"
cl_logofile "lambda"
cl_lw "1"
cl_minmodels "0"
cl_radartype "1"
cl_righthand "1"
cl_shadows "1"
cl_timeout "600"
cl_updaterate "101.0"
cl_vsmoothing "0.05"
cl_weather "0"
con_color "255 180 30"
console "0.000000"
crosshair "1"
fastsprites "2"
fps_max "101"
fps_modem "101"
gamma "3"
gl_dither "1"
gl_flipmatrix "0"
gl_fog "1"
gl_monolights "0"
gl_overbright "0.000000"
gl_polyoffset "4.0"
hisound "1.000000"
hpk_maxsize "1"
hud_capturemouse "1"
hud_centerid "1"
hud_draw "1"
hud_fastswitch "1"
hud_saytext_internal "1"
hud_takesshots "0"
joystick "0"
lookspring "0.000000"
lookstrafe "0.000000"
m_filter "1"
m_forward "1"
m_pitch "0.022"
m_side "0.8"
m_yaw "0.022"
model "gordon"
MP3FadeTime "2.0"
MP3Volume "0.8"
mp_decals "300"
name "WAYZIQ CONFIG I REAL AIM""
net_graph "0"
net_graphpos "2"
net_scale "5"
r_bmodelhighfrac "5.0"
r_detailtextures "0"
s_a3d "0.000000"
s_automax_distance "30.0"
s_automin_distance "2.0"
s_bloat "2.0"
s_distance "60"
s_doppler "0.0"
s_eax "0.0"
s_leafnum "0"
s_max_distance "1000.0"
s_min_distance "8.0"
s_numpolys "200"
s_polykeep "1000000000"
s_polysize "10000000"
s_refdelay "0"
s_refgain "0.0"
s_rolloff "1.0"
s_verbwet "0.25"
sensitivity "1"
skin ""
spec_autodirector_internal "1"
spec_drawcone_internal "1"
spec_drawnames_internal "1"
spec_drawstatus_internal "1"
spec_mode_internal "2"
spec_pip "0"
violence_ablood 10
violence_agibs 10
violence_hblood 10
violence_hgibs 10
suitvolume "0.250000"
sv_aim "0"
sv_voiceenable "0"
team ""
topcolor "30"
viewsize "120.000000"
voice_enable "1"
voice_forcemicrecord "1.000000"
voice_modenable "0"
voice_scale "2.000000"
volume "0.3"
setinfo "_vgui_menus" "0"
zoom_sensitivity_ratio 1.2

@ @
@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ AIM !
@
@ @



alias xwm-siga "avadd 0 21.92 8.59 2.69;avadd 0 21.96 8.59 2.59;avadd 0 21.85 7.59 2.39;avadd 0 21.82 7.29 2.59"
alias xwm-sigb "avadd 0 21.74 8.48 2.38;avadd 0 21.73 8.38 2.38;avadd 0 21.69 6.58 2.58;avadd 0 21.65 7.28 2.18"
alias xwm-sigc "avadd 0 21.55 6.77 2.17;avadd 0 21.56 6.67 2.27;avadd 0 21.52 7.77 2.77;avadd 0 21.55 7.47 2.17"
alias xwm-sigd "avadd 0 20.23 6.56 1.86;avadd 0 20.27 6.36 2.76;avadd 0 20.35 6.56 2.76;avadd 0 20.38 6.26 2.56"
alias xwm-sige "avadd 0 19.94 5.45 2.45;avadd 0 19.93 5.35 2.55;avadd 0 19.95 7.25 2.65;avadd 0 19.92 7.25 2.85"
alias xwm-sigf "avadd 0 19.82 8.24 3.34;avadd 0 19.82 8.24 4.24;avadd 0 19.85 8.54 2.54;avadd 0 19.87 8.84 2.84"
alias xwm-sigg "avadd 0 19.71 8.13 3.13;avadd 0 19.72 8.23 3.63;avadd 0 19.44 8.43 3.63;avadd 0 19.55 8.53 2.53"
alias xwm-sigh "avadd 1 24.52 5.52 2.62;avadd 1 24.65 1.42 2.52;avadd 1 24.73 1.62 2.72;avadd 1 24.83 1.82 3.72"
alias xwm-sigi "avadd 1 24.51 4.51 3.11;avadd 1 24.52 6.51 5.11;avadd 1 24.65 6.71 5.21;avadd 1 24.63 6.81 5.31"
alias xwm-sigj "xwm-siga;xwm-sigb;xwm-sigc;xwm-sigd;xwm-sige;xwm-sigf;xwm-sigg;xwm-sigh;xwm-sigi"
alias xwm-sigx "avclear;xwm-sigj;recoil 1.35;txt _-=** X|treme |W|4|2M0n|k3Y [d0p3W4|2 s1g] **=-_"

alias xwm-clta "avadd 0 22.9002 5.9888 1.2331;avadd 1 30.2099 4.1201 3.1510"
alias xwm-cltb "avadd 0 23.0099 5.9888 2.4331;avadd 1 29.2098 4.0001 3.3010"
alias xwm-cltc "avadd 0 23.1099 6.0011 4.2333;avadd 1 28.2098 3.9801 3.5015"
alias xwm-cltd "xwm-clta;xwm-cltb;xwm-cltc"
alias xwm-cltx "avclear;xwm-cltd;recoil 1.5;txt _-=** X|treme |W|4|2M0n|k3Y [d0p3W4|2 m4a1] **=-_"

alias xwm-scta "avadd 0 22.209 7.56 2.62;avadd 0 21.719 8.45 3.12;avadd 0 23.209 6.21 2.71;avadd 0 22.82 6.23 2.12"
alias xwm-sctb "avadd 1 30.21 4.11 3.12;avadd 1 28.31812 6.72211 4.15312;avadd 1 30.0011 4.00221 4.00221;avadd 1 30 4 4"
alias xwm-sctx "avclear;xwm-scta;xwm-sctb;recoil 1.5;txt _-=** X|treme |W|4|2M0n|k3Y [d0p3w4|2 sc0u7] **=-_"

alias xwm-ak4a "avadd 0 22.9002 5.9888 1.2331;avadd 1 30.2099 4.1201 3.1510"
alias xwm-ak4b "avadd 0 23.0099 5.9888 2.4331;avadd 1 29.2098 4.0001 3.3010"
alias xwm-ak4c "avadd 0 23.1099 6.0011 4.2333;avadd 1 28.2098 3.9801 3.5015"
alias xwm-ak4d "xwm-ak4a;xwm-ak4b;xwm-ak4c"
alias xwm-ak4x "avclear;xwm-ak4d;recoil 1.7;txt _-=** X|treme |W|4|2M0n|k3Y [d0p3W4|2 aK47] **=-_"

alias xwm-mp5a "avadd 0 22 9.2 2.5"
alias xwm-mp5b "avadd 0 21.82 9.31 1.52"
alias xwm-mp5c "avadd 1 25.12 6.16 2.33"
alias xwm-mp5d "xwm-mp5a;xwm-mp5b;xwm-mp5c"
alias xwm-mp5x "avclear;xwm-mp5d;recoil 1.75;txt _-=** X|treme |W|4|2M0n|k3Y [d0p3W4|2 Mp5] **=-_"

////////////////////////////////////////////////////////////////////////////////////////////////

alias xbh-clta "avadd 0 22.6 2 0;avadd 1 22.5 2.2 -1"
alias xbh-cltb "avadd 0 23 1.7 0;avadd 1 23.2 3 -1.2"
alias xbh-cltx "avclear;xbh-clta;xbh-cltb;recoil 1.5;txt *** X|treme |D|uStB@g|H34V3N| |CoLt MaStA| ***"

alias xbh-siga "avadd 0 22.643 2.12 0.2;avadd 1 22.54 2.22 -1.1"
alias xbh-sigb "avadd 0 23.12 1.73 0.1;avadd 1 23.256 3.12 -1.23"
alias xbh-sigx "avclear;xbh-siga;xbh-sigb;recoil 1.4;txt *** X|treme |D|uStB@g|H34V3N| |SiG MaStA| ***"

alias xbh-ak4a "avadd 0 22.6432 2.121 0.21;avadd 1 22.541 2.223 -1.12"
alias xbh-ak4b "avadd 0 23.122 1.734 0.11;avadd 1 23.2561 3.125 -1.234"
alias xbh-ak4x "avclear;xbh-ak4a;xbh-ak4b;recoil 1.9;txt *** X|treme |D|uStB@g|H34V3N| |AK MaStA| ***"

alias xbh-scta "avadd 0 22.8 6.5 0.34;avadd 1 23 7 0"
alias xbh-sctb "avadd 0 23.3 5 -1;avadd 1 22 7.2 -1.2"
alias xbh-sctx "avclear;xbh-scta;xbh-sctb;recoil 1.8;txt *** X|treme |D|uStB@g|H34V3N| |ScoUt MaStA| ***"

alias xbh-mp5a "avadd 0 22.82 6.53 0.341;avadd 1 23.2 7.1 0.12"
alias xbh-mp5b "avadd 0 23.34 5.4 -1.2;avadd 1 22.3 7.22 -1.24"
alias xbh-mp5x "avclear;xbh-mp5a;xbh-mp5b;recoil 2.0;txt *** X|treme |D|uStB@g|H34V3N| |Mp5 MaStA| ***"

////////////////////////////////////////////////////////////////////////////////////////////////

alias nwf-siga "avadd 0 22.765 8.4523 1.654;avadd 1 25.653 9.542 4.76"
alias nwf-sigb "avadd 0 21.324 9.7427 3.813;avadd 1 24.124 8.872 5.32"
alias nwf-sigx "avclear;nwf-siga;nwf-sigb;recoil 1.3;txt *** [L337-H@X]Night_Wolf [SiG w00t!!] ***"

alias nwf-ak4a "avadd 0 21.543 4.564 2.34345;avadd 0 21.345345 8.342 1.654;avadd 0 22.564 6.342 3.6546"
alias nwf-ak4b "avadd 1 24.654 3.765 1.75671;avadd 1 24.876412 7.432 -1.54;avadd 1 22.863 5.432 2.6546"
alias nwf-ak4x "avclear;nwf-ak4a;nwf-ak4b;recoil 1.7;txt *** [L337-H@X]Night_Wolf [AK w00t!!] ***"

alias nwf-mp5a "avadd 0 21.435 3.123 1.342 19.564 9.324 2.3424 22.8732 8.324 4.235"
alias nwf-mp5b "avadd 1 23.764 5.342 3.758 26.432 10.32 5.6752 24.5435 -3.65 -1.34"
alias nwf-mp5x "avclear;nwf-mp5a;nwf-mp5b;recoil 1.3;txt *** [L337-H@X]Night_Wolf [Mp5 w00t!!] ***"

alias nwf-clta "avadd 0 18.6546 4.45354 1.3423;avadd 1 22.5435 4.45645 1.3432"
alias nwf-cltb "avadd 0 19.265 5.4563 2.343265;avadd 1 23.8763 5.76234 2.5435"
alias nwf-cltc "avadd 0 20.432 6.4534 3.453453;avadd 1 24.4324 6.54354 3.5435"
alias nwf-cltd "avadd 0 21.765 7.34543 4.76576;avadd 1 25.5435 7.54354 4.5645"
alias nwf-clte "avadd 0 22.543 8.43245 5.32158;avadd 1 26.4324 8.34243 5.3424"
alias nwf-cltf "nwf-clta;nwf-cltb;nwf-cltc;nwf-cltd;nwf-clte"
alias nwf-cltx "avclear;nwf-cltf;recoil 1.5;txt *** [L337-H@X]Night_Wolf [CoLT w00t!!] ***"

alias nwf-scta "avadd 0 20.255 9.1 2.5431;avadd 1 26 6.658 5.24343"
alias nwf-sctb "avadd 0 21.03 8.11 3.7659;avadd 1 25 7.343 4.42342"
alias nwf-sctc "avadd 0 22.14 7.91 4.7651;avadd 1 24 8.343 3.432354"
alias nwf-sctd "avadd 0 23.11 6.5176 5.7651;avadd 1 23 9.3257 2.53465"
alias nwf-scte "nwf-scta;nwf-sctb;nwf-sctc;nwf-sctd"
alias nwf-sctx "avclear;nwf-scte;recoil 1.2;txt *** [L337-H@X]Night_Wolf [Sc0uT w00t!!] ***"

////////////////////////////////////////////////////////////////////////////////////////////////

alias xec-ak4a "avadd 0 21.2 7.8 4;avadd 0 21.2 8 3;avadd 0 21.8 8 2"
alias xec-ak4b "avadd 1 25.9 4.0 2;avadd 1 25.7 4 4;avadd 1 26.3 4 3"
alias xec-ak4x "avclear;xec-ak4a;xec-ak4b;recoil 1.2;txt *** X|treme |E|nclave [$UP3|R AK] ***"

alias xec-mp5a "avadd 0 21 6.9 0.8;avadd 1 21.0 1.5 0.9"
alias xec-mp5x "avclear;xec-mp5a;recoil 1.8;txt *** X|treme |E|nclave [$UP3|R MP5] ***"

alias xec-scta "avadd 0 23 6.5 4.0;avadd 1 29.2 6.0 6.0"
alias xec-sctx "avclear;xec-scta;recoil 2.0;txt *** X|treme |E|nclave [$UP3|R SCOUT] ***"

alias xec-siga "avadd 0 23.59987 6.9987 2.0187;avadd 0 23.5 8 3;avadd 0 23.0 8 4;avadd 0 23 8 2"
alias xec-sigb "avadd 1 24.59987 5.9987 1.0187;avadd 1 25.2 4 3;avadd 1 24.7 4 2;avadd 1 24.7 4"
alias xec-sigx "avclear;encsig1;encsig2;recoil 1.7;txt *** X|treme |E|nclave [$UP3|R SIG] ***"

alias xec-clta "avadd 0 22.32 5.20 2"
alias xec-cltb "avadd 1 23.53 8.92 2"
alias xec-cltx "avclear;xec-clta;xec-cltb;recoil 1.6;txt *** X|treme |E|nclave [$UP3|R COLT] ***"

////////////////////////////////////////////////////////////////////////////////////////////////

alias mcg-ak4a "avadd 0 23.0 7 3;avadd 1 25.2 4.0 4.1"
alias mcg-ak4b "avadd 0 23.0 6 2;avadd 1 25.2 3.1 4.0"
alias mcg-ak4c "avadd 0 23.1 5 2;avadd 1 25.2 4.0 3.2"
alias mcg-ak4d "avadd 0 23.0 4 1;avadd 1 25.6 3.5 4.5"
alias mcg-ak4e "avadd 0 23.1 6 2;avadd 1 25.6 4.5 3.5"
alias mcg-ak4f "mcg-ak4a;mcg-ak4b;mcg-ak4c;mcg-ak4d;mcg-ak4e"
alias mcg-ak4x "avclear;mcg-ak4f;recoil 1.5;txt *** [R-SouljaZ]MacGyver [AK H[]T] ***"

alias mcg-scta "avadd 0 23.9 4.6 4.3;avadd 0 24.10 5.31 4.1;avadd 0 24.14 3.01 1.6"
alias mcg-sctb "avadd 1 24.3 5.1 2.1;avadd 1 23.13 4.76 3.6;avadd 1 25.10 4.19 2.5"
alias mcg-sctx "avclear;mcg-scta;mcg-sctb;recoil 1.7;txt *** [R-SouljaZ]MacGyver [SCOUT H[]T] ***"

alias mcg-mp5a "avadd 0 20.1 7 2;avadd 1 19.2 3.0 2.0"
alias mcg-mp5b "avadd 0 16.1 6 2;avadd 1 18.2 2.1 3.1"
alias mcg-mp5c "avadd 0 17.1 7 2;avadd 1 16.2 3.0 2.0"
alias mcg-mp5d "avadd 0 18.1 6 2;avadd 1 17.6 2.5 3.5"
alias mcg-mp5e "avadd 0 19.1 7 2;avadd 1 19.6 3.5 2.5"
alias mcg-mp5f "mcg-mp5a;mcg-mp5b;mcg-mp5c;mcg-mp5d;mcg-mp5e"
alias mcg-mp5x "avclear;mcg-mp5f;recoil 1.5;txt *** [R-SouljaZ]MacGyver [MP5 H[]T] ***"

alias mcg-siga "avadd 0 22.1 7.3 4.2;avadd 1 20.1 3.1 2.2"
alias mcg-sigx "avclear;mcg-siga;recoil 1.8;txt *** [R-SouljaZ]MacGyver [SIG H[]T] ***"

alias mcg-clta "avadd 0 23.3 6.1 2.9;avadd 1 28.1 6.1 3.1"
alias mcg-cltx "avclear;mcg-clta;recoil 1.5;txt *** [R-SouljaZ]MacGyver [COLT H[]T] ***"

////////////////////////////////////////////////////////////////////////////////////////////////

alias xdr-mp5a "avadd 0 20.23 7.331 5;avadd 1 26.2 6.4 5"
alias xdr-mp5x "avclear;xdr-mp5a;recoil 1.5;txt |-- X|treme |D|r@ma Mp5 --|"

alias xdr-scta "avadd 0 22.2 7.1 4;avadd 1 26.4 5 5"
alias xdr-sctx "avclear;xdr-scta;recoil 1.7;txt |-- X|treme |D|r@ma sC0ut --|"

alias xdr-siga "avadd 0 22 9 4;avadd 1 26.1 6.4 5"
alias xdr-sigx "avclear;xdr-siga;recoil 1.4;txt |-- X|treme |D|r@ma S!g --|"

alias xdr-clta "avadd 0 22.5 7 4;avadd 1 25 4.4 5"
alias xdr-cltx "avclear;xdr-clta;recoil 1.4;txt |-- X|treme |D|r@ma c0Lt --|"

alias xdr-ak4a "avadd 0 22.29 8 4;avadd 1 24.5 6 5"
alias xdr-ak4x "avclear;xdr-ak4a;recoil 1.6;txt |-- X|treme |D|r@ma Ak47 --|"

////////////////////////////////////////////////////////////////////////////////////////////////

alias yde-clta "avadd 0 23.7 8.2 2.6;avadd 1 25.8 8.2 2.6"
alias yde-cltb "avadd 0 21.7 8.2 1.65;avadd 1 24.5 6.2 1.8"
alias yde-cltx "avclear;yde-clta;yde-cltb;recoil 1.5;txt ** [FuRy]-y0d3 [c0Lt AiM] **"

alias yde-siga "avadd 0 23.38 7.1 4.87;avadd 0 24.92 6.87 2.39"
alias yde-sigb "avadd 1 26.3 4.21 5;avadd 1 28.22 2.3 4.1"
alias yde-sigx "avclear;yde-siga;yde-sigb;recoil 1.6;txt ** [FuRy]-y0d3 [s][g AiM] **"

alias yde-mp5a "avadd 0 22.2990 6.51 4.53;avadd 1 25 6.51 4.53"
alias yde-mp5b "avadd 0 22.2990 5.28 4.53;avadd 1 25 5.28 4.53"
alias yde-mp5x "avclear;yde-mp5a;yde-mp5b;recoil 2.0;txt ** [FuRy]-y0d3 [mP5 AiM] **"

alias yde-ak4a "avadd 0 22.25 6.52 3.1;avadd 1 25.42 5.32 3.1"
alias yde-ak4b "avadd 0 21.89 6.26 2.7;avadd 1 26.08 3.56 2.6"
alias yde-ak4c "avadd 0 21.60 5.79 2.2;avadd 1 25.73 3.24 2.4"
alias yde-ak4d "yde-ak4a;yde-ak4b;yde-ak4c"
alias yde-ak4x "avclear;yde-ak4d;recoil 1.4;txt ** [FuRy]-y0d3 [aK47 AiM] **"

alias yde-scta "avadd 0 23.5 6.35 3.43;avadd 1 28.65 3.458 5.4"
alias yde-sctx "avclear;yde-scta;recoil 2.0;txt ** [FuRy]-y0d3 [sCOUt AiM] **"

Cadou din partea lui snAke --> Adica OnlyLnG >:)




_cs_restrict 0
_debug 0
_fx 0
_gag_name 0
_ignore_immunity 1.89
_repeat_freq 600
_duration 30
// Defines the max time length in seconds of voting process.
amv_vote_duration 30

// Default access rights for players not in the users.ini file.
// (See documentation for access levels and information)
default_access 1

// Whether to use encrypted passwords or not.
// 0: disabled
// 1: encrypt using Unix crypt() (Linux ONLY)
// 2: encrypt using MD5 hash
// 3: encrypt using MySQL PASSWORD() (MySQL ONLY)




// If enabled, the scripting file functions have read
// access to files
// (0=disabled, 1=enabled)








f defined _included
pragma semicolon 1
enum print_type {
print_console=0,
print_center,
print_chat,
print_tty,
print_pretty
};

enum fsize_unit {
bytes = 0,
lines
};

const bBanByID = 0;
const bBanByIP = 1;
const bBanBoth = 2;

enum uid {
uid_none = 0,
uid_invalid,
uid_index,
uid_sessionID,
uid_wonID,
};

/* Defined as '+ 1' so when we make an array[MAXPLAYERS], we get the range from 0 - 32. */
#define MAX_PLAYERS 32 + 1
#define TEAM_PROXY 600
#define TEAM_SPECTATOR 500

#define MAX_NUMBER_LENGTH 20
#define MAX_COMMAND_LENGTH 30
#define MAX_NAME_LENGTH 33
#define MAX_DATA_LENGTH 200
#define MAX_TEXT_LENGTH 200
#define MAX_AUTHID_LENGTH 39

#define PLUGIN_HANDLED -1
#define PLUGIN_FAILURE 0
#define PLUGIN_CONTINUE 1

#define ACCESS_ALL 0
#define ACCESS_TIMELEFT 0
#define ACCESS_USERLIST 0
#define ACCESS_VERSION 0
#define ACCESS_VOTE_KICK 1
#define ACCESS_VOTE_MAP 1
#define ACCESS_FRAGLIMIT 2
#define ACCESS_MAP 2
#define ACCESS_TIMELIMIT 2
#define ACCESS_ABORT_VOTE 2
#define ACCESS_RELOAD 4
#define ACCESS_PAUSE 8
#define ACCESS_PASS 16
#define ACCESS_FRIENDLY_FIRE 32
#define ACCESS_GRAVITY 32
#define ACCESS_TEAMPLAY 32
#define ACCESS_CHAT 64
#define ACCESS_SAY 64
#define ACCESS_KICK 128
#define ACCESS_BAN 256
#define ACCESS_CONFIG 512
#define ACCESS_IMMUNITY 4096
#define ACCESS_RCON 65536 /* Define this to 512 to have Alfred's setting */
#define ACCESS_RESERVE_NICK 16384 /* This is never used in the script; just for reference */
#define ACCESS_RESERVE_SPOT 32768 /* This is never used in the script; just for reference */


forward plugin_init();
forward plugin_info(HLOldName, HLNewName, UserIndex);
forward plugin_connect(HLUserName, HLIP, UserIndex);
forward plugin_disconnect(HLUserName, UserIndex);
forward plugin_command(HLCommand, HLData, HLUserName, UserIndex);

native access( iAccess, sName[] = "" );
native auth( sName[] = "");
native ban( sPlayer[], iTime, bBanBy = bBanByID );
native censor_words( sString[] );
native centersay( sText[], iTime, iRed, iGreen, iBlue );
native centersayex( sUser[], sText[], iTime, iRed, iGreen, iBlue );
native changelevel( sMap[], iIntermissionPause = 0 );
native cvar_exists( sCvar[] );
native check_user( sPlayer[] );
native check_words( sPlayer[] );
native consgreet( sMessage[] );
native convert_string( iHLString, sSmallString[], iMaxLength );
native currentmap( iMap[], iMaxLength );
native directmessage( sMessage[], iUserID = -1, uid:tUidType = uid:uid_sessionID );
native exec( sCommand[], bWriteLogEntry = 1 );
native execclient( sPlayer[], sCommand[] );
native get_serverinfo( sKey[], sValue[], iMaxLength );
native get_timer( iTimer );
native get_userAuthID( sPlayer[], sAuthid[], iMaxLength = MAX_AUTHID_LENGTH );
native get_userindex( sPlayer[], &iIndex );
native get_userinfo( sPlayer[], sKey[], sInfo[], iMaxLength );
native get_userIP( sPlayer[], sIP[], iMaxLength, &iPort = 0 );
native get_username( sPlayer[], sName[], iMaxLength );
native get_userorigin( sPlayer[], &iX, &iY, &iZ );
native get_userSessionID( sPlayer[], &iSessionID );
native get_userWONID( sPlayer[], &iWONID );
native get_vaultdata( sKey[], sData[], iMaxLength );
native get_vaultnumdata( sKey[], &iData );
native getstrvar( sVarname[], sValue[], iMaxLength );
native gettarget( sPlayer[], sTargetName[], iMaxLength, iRange = 2048 );
native getteamcount( iTeam );
native getvar( sVarname[] );
native glow( sTarget[], iRed = 0, iGreen = 0, iBlue = 0 );
native godmode( sPlayer[], iOnOff );
native help( sKeyword[] );
native kick( sPlayer[] );
native kill_timer( iTimer );
native list_maps( );
native log( sLogEntry[] );
native look_in_dir( sDirectory[], sMatch[], sFilename [], iNumber );
native maptime( iWhichtime, iPrintToConsole = 0 );
native maxplayercount( );
native message( sTarget[], sMessage[] );
native messageex( sTarget[],sMessage[], print_type:iMessageType );
native motd( sPlayer[], Text[] );
native nextmap( sMap[], iMaxLength );
native noclip( sPlayer[], iOnOff );
native playercount( );
native playerinfo( iPlayerIndex, sName[], iLength, &iUserID = 0, &iWONID = 0, &iTeam = 0, &iDead = 0, sAuthID[MAX_AUTHID_LENGTH] = "" );
native playsound( sTarget[], iSound[] );
native pointto( iRange = 2048 );
native rainbow( sText[], iTime, iRedStart, iGreenStart, iBlueStart, iRedEnd, iGreenEnd, iBlueEnd );
native reload( );
native say( sMessage[] );
native selfmessage( sMessage[] );
native servertime( sTimeString[], iMaxLen, sFormat[] = "none" );
native set_serverinfo( sKey[], sValue[] );
native set_timer( sFunction[], iWaitSeconds, iRepeatCount, sParameter[] = "" );
native set_vaultdata( sKey[], sData[] );
native set_vaultnumdata( sKey[], iData );
native slap( sPlayer[] );
native slay( sPlayer[] );
native speakto( sTarget[], iSentence[] );
native strtonum( sString[] );
native systemtime( );
native teleport( sPlayer[], iX, iY, iZ );
native timeleft( iPrintToConsole = 1 );
native typesay( sMessage[], iTime, iRed, iGreen, iBlue );
native unban( sWONID[] );
native userlist( sPattern[] = "" );
native valid_map( sMap[] );
native valid_mapex( sMap[], ignoreMapsFile = 0 );
native version( );
native vote( sVoteString[], ... );
native vote_allowed( );

native spawn( sClass[], iX, iY, iZ, iXAngle, iYAngle, iZAngle );
native listspawn( sClass[] );
native movespawn( iIdentity, iX, iY, iZ, iXAngle, iYAngle, iZAngle );
native removespawn( iIdentity );

native fileexists( sFilename[] );
native filesize( sFilename[], fsize_unit:Unit = 1 );
native readfile( sFilename[], sLine[], iLineNum, iMaxLength );
native writefile( sFilename[], sLine[], iLineNum = -1 );
native resetfile( sFilename[] );
native deletefile( sFilename[] );

native plugin_exec( sCommand[], sArguments[] );
native plugin_registercmd( Command[], Function[], RequiredAccess, HelpMessage[] = "" );
native plugin_registerhelp( Command[], RequiredAccess, HelpMessage[] );
native plugin_registerinfo( Name[], Description[], Version[]);

native setstrvar( cvar[], value[]);
native menu(username[],text[],keys,time=0);

native get_userFrags( sPlayer[], &frags );
native get_userHealth(sPlayer[], &health );
native get_userTeam( sPlayer[], &team );
native get_userArmor( sPlayer[], &armor );





/* Core functions



........




*
* (c) Copyright 1998-2002, ITB CompuPhase
* This file is provided as is (no warranties).
*/
#if defined _core_included
#endinput
#endif
#define _core_included

native heapspace();

native funcidx(const name[]);

native numargs();
native getarg(arg, index=0);
native setarg(arg, index=0, value);

native strlen(const string[]);
native strpack(dest[], const source[]);
native strunpack(dest[], const source[]);

native tolower(c);
native toupper(c);
native swapchars(c);

native random(max);

/* We use the Small versions in adminlib.inc instead
native min(value1, value2);
native max(value1, value2);
*/
native clamp(value, min=cellmin, max=cellmax);

native getproperty(id=0, const name[]="", value=cellmin, string[]="");
native setproperty(id=0, const name[]="", value=cellmin, const string[]="");
native deleteproperty(id=0, const name[]="", value=cellmin);
native existproperty(id=0, const name[]="", value=cellmin)





#include
#include

#define CHAR_INVALID -1
#define FALSE 0
#define NULL_CHAR 0
#define PERIOD_CHAR 46
#define QUOTE_CHAR 34
#define TRUE 1

/* Returns 1 if the current user has the required auth level, 0 otherwise */
stock check_auth( iAuthLevel ) {
new iResult = access(iAuthLevel,"");
if (iResult!=0) iResult = 1;
return iResult;
}

/* Returns the lesser of a and b */
stock min(a,b) {
if (aelse return b;
return 1;
}

/* Returns the greater of a and b */
stock max(a,b) {
if (a>b) return a;
else return b;
return 1;
}

/* Executes a command while providing the nicely formatted output */
stock execute_command(sUser[], sCommand[], sHalfLifeCmd[], sData[]) {
new sRconCmd[MAX_DATA_LENGTH];

say_command(sUser,sCommand,sData);
snprintf(sRconCmd, MAX_DATA_LENGTH, "%s %s", sHalfLifeCmd, sData);
exec(sRconCmd);
}

/* Nicely formats the current command */
stock format_command(sUser[],sCommand[],sData[],sText[]) {
snprintf(sText, MAX_TEXT_LENGTH, "Command: %s used command %s %s", sUser, sCommand, sData);
}

/* Logs a command */
stock log_command(sUser[],sCommand[],sData[]) {
new sText[MAX_TEXT_LENGTH];
format_command(sUser,sCommand,sData,sText);
log(sText);
}

/* NumToStr courtesy of Nathan O'Sullivan (http://nathan.qgl.org/halflifeadmin/numtostr.txt) */
stock numtostr(num,str[]) {
new Base = 1;
new Digits = 1;
new i = 0;

/* Special case: 0 */
if (num == 0) {
str[i++] = '0';
str[i++] = NULL_CHAR;
} else {
/* If we've got a negative number, add a negative sign
to the string, and multiply the number by -1 */
if (num < 0) {
str[i++] = '-';
num *= -1;
}

/* Ok. We've got at least one digit. Keep multiplying by
10 till we get a higher number than what we've got. Note
that this will leave Digits 1 higher than what we want (eg,
if Num was 7, Digits will be 2 */
while (Base <= num) {
Base *= 10;
Digits++;
}

/* Because Digits is higher, use --Digits rather than Digits--.
Also, divide Base before using it. */
while (--Digits > 0) {
Base /= 10;
str[i++] = '0' + (num - (num % Base)) / Base;
num = num % Base;
}
str[i++] = NULL_CHAR;
}
}

/* Command to use when the person doesn't have the proper permissions. */
stock reject_message(iPublic = 0) {
new sText[MAX_TEXT_LENGTH];

getstrvar("admin_reject_msg",sText,MAX_TEXT_LENGTH );
if(strlen(sText) < 2)
strcpy(sText, "You do not have access to this command.", MAX_TEXT_LENGTH);
if (iPublic == 0) {
selfmessage(sText);
} else {
say(sText);
}
}

/* Results differ upon the setting of admin_quiet. If admin_quiet
is 0, says who executed what command. If admin_quiet is 1, says
'Admin' executed what command. Otherwise, simply logs.
The override option allows one to ignore admin_quiet, and always
display a message.
*/
stock say_command(sUser[],sCommand[],sData[], iOverride = 0) {
new iQuiet;
new sText[MAX_TEXT_LENGTH];

iQuiet = getvar("admin_quiet");
if (iQuiet==0) {
format_command(sUser,sCommand,sData,sText);
say(sText);
} else if (iQuiet==1 || iOverride==1) {
format_command("Admin",sCommand,sData,sText);
say(sText);
} else {
log_command(sUser,sCommand,sData);
}
}



/* Given a string (str[]), this will attempt to break it apart at the first
space that's not inside quotation marks. Quotes at the beginning and end
will be stripped. Ie,

new str[20] = "This is a test"
new first[20];
new second[20];
strbreak(str,first,second, 20);

first is now equal to "This", and second is now equal to "is a test". If
str[] had been "^"This is^" a test", first would be "This is" and second would
be "a test".
At maximum maxlen characters will be copied. */
stock strbreak(str[], first[], second[], maxlen, flen=sizeof first, slen=sizeof second ) {
new i = 0;
new j = 0;
new NullPos = CHAR_INVALID;
new Quote = FALSE;
new SpacePos = CHAR_INVALID;
new iFirstEnd;
new iSecondEnd;

if (maxlen == 0)
maxlen = strlen(str);



// Find the position of the first unquoted space and the terminating NULL character
for(i=0; i<=strlen(str); i++)














if (str[i] == QUOTE_CHAR) {
if (Quote==FALSE) {
Quote = TRUE;
} else {
Quote = FALSE;
}
} else if (str[i] == ' ' && SpacePos == CHAR_INVALID && Quote == FALSE) {
SpacePos = i;
} else if (str[i] == NULL_CHAR) {
NullPos = i;
break;
}
}

if (NullPos == CHAR_INVALID) NullPos = maxlen + 1;


if (SpacePos == CHAR_INVALID) {
strcpy(first, str, flen);
strinit(second);

} else {
// Make sure we do not copy more characters into the second array
// than would fit into it. If the second part of the source string
// is longer than the length of the second array, truncate it to fit.
new iSecondLen = NullPos - SpacePos -1;
iSecondEnd = min( iSecondLen, (slen-1) );

// If maxlen is set we want to copy only max maxlen characters.
// Check if this is smaller than our current limit
iSecondEnd = min( iSecondEnd, maxlen );

// Make sure we do not copy more characters into the first array
// than would fit into it. If the first part of the source string
// is longer than the length of the first array, truncate it to fit.
iFirstEnd = min( SpacePos, (flen-1) );

// If maxlen is set we want to copy only max maxlen characters.
// Check if this is smaller than our current limit
iFirstEnd = min( iFirstEnd, maxlen );


// Copy the first part of the string into the first array
for( i = 0; i < iFirstEnd; i++) {
first[i] = str[i];
}
// Zero-terminate the first array
first[iFirstEnd] = NULL_CHAR;


// Copy the second part of the string into the second array
for( i = SpacePos+1, j = 0; j < iSecondEnd; i++, j++) {
second[j] = str[i];
}
// Zero-terminate the second array
second[iSecondEnd] = NULL_CHAR;
}


/* Strip out the quotes of the return values. */
strstripquotes(first);
strstripquotes(second);
}


/* Counts the number of times searchchar appears in str[] */
/*
stock strcount(str[], searchchar) {
new i = 0;
new maxlen = strlen(str);
new Count = 0;

for(i = 0; i <= maxlen; i++) {
if (str[i] == searchchar)
Count++;
}
return Count;
}
*/

/* Returns 1 if two strings are exactly the same, including length, etc */
stock streq( strOne[], strTwo[] ) {
if (strlen(strOne) != strlen(strTwo)) {
return 0;
} else if (strcasecmp(strOne, strTwo)==0) {
return 1;
}
return 0;
}

/* Initialize a string */
stock strinit( sString[] ) {
sString[0] = NULL_CHAR;
}

/* returns 1 if two strings are the same in the first Length (or less
if one is smaller than Length) digits, 0 otherwise */
stock strmatch( sOne[], sTwo[], iLength) {
if (strncasecmp(sOne, sTwo, iLength)==0) {
return 1;
}
return 0;
}

/* Strips the quotes from the beginning and ending, if they exist. Ignores
those in the middle. */
stock strstripquotes(str[]) {
new maxlen = strlen(str);
new i;

if(maxlen==0)
return;

if(str[maxlen - 1]==QUOTE_CHAR)
str[--maxlen] = NULL_CHAR;

if(str[0] == QUOTE_CHAR) {
for(i=0; i<=maxlen; i++)
str[i] = str[i+1];
str[i-2] = NULL_CHAR;
}
}

/* I had this in the normal alphabetical order...but it caused
the Small compiler to barf. So I moved it down here, and it's
fine. That doesn't fill me with inspiration, but it seems
to work. */
/* Returns 1 if param is '1' or 'on'...0 for anything else. */
stock check_param( sParam[] ) {
new iResult = 0;

if(strlen(sParam) > 0) {
if (streq(sParam, "on")==1) {
iResult = 1;
} else if (streq(sParam, "1")==1) {
iResult = 1;
}
}
return iResult;
}

/* Returns 1 if the target has immunity */
stock check_immunity( sTarget[] ) {
/* If the server doesn't honor immunity, no one is immune. */
if (getvar("admin_ignore_immunity")!=0) {
return 0;
/* Else, you're immune if you have that access level. */
} else if (access(ACCESS_IMMUNITY,sTarget)!=0) {
return 1;
}
return 0;
}


stock ( sCommand[] ) {

new Target[MAX_NAME_LENGTH];
new i;
new iSessionID;
new sSessionID[MAX_NUMBER_LENGTH];
new maxplayers = maxplayercount();

for(i=1; i<=maxplayers; i++) {
strinit(Target);
if(playerinfo(i,Target,MAX_NAME_LENGTH, iSessionID)==1) {
numtostr( iSessionID, sSessionID );


} // if
} // for




/********************************** PUBLIC UTILITY FUNCTIONS *****************************/

/* Called by changelevel() by a timer call. Do not remove!
Changes map to specified map by calling changelevel with
specific parameters. */
public ChangeMap(Timer,Repeat,HLUser,HLParam) {
new NewMap[MAX_NAME_LENGTH];

convert_string(HLParam,NewMap,MAX_NAME_LENGTH);
if(strlen(NewMap) != 0) {
changelevel(NewMap, -1);
}
}






/* Console input/output functions
*
* (c) Copyright 1998-2002, ITB CompuPhase
* This file is provided as is (no warranties).
*/
#if defined _console_included
#endinput
#endif
#define _console_included

enum
{
black, /* colours as per the ANSI Escape sequences, ISO 6429 */
red,
green,
yellow,
blue,
magenta,
cyan,
white,
}

native getchar(echo=true);
native getstring(string[], maxlength, boolack=false);
native getvalue(base=10, end='^r', ...);
native print(const string[], foreground=-1, background=-1);
native printf(const format[], ...);







?????????????????????????????????????????????????? ??????????????????????????????????????????????






/* Fixed point arithmetic
*
* (c) Copyright 1998-2002, ITB CompuPhase
* This file is provided as is (no warranties).
*/
#if defined _fixed_included
#endinput
#endif
#define _fixed_included

enum fround_method {
fround_round,
fround_floor,
fround_ceil
}

native fixed:fixed(value);
native fixed:fixedstr(const string[]);
native fixed:fmul(fixed:oper1, fixed:oper2);
native fixed:fdiv(fixed:dividend, fixed:divisor);
native fixed:ffract(fixed:value);
native fround(fixed:value, fround_method:method=fround_round);

#pragma rational fixed(3)

/* user defined operators */
native fixed:operator*(fixed:oper1, fixed:oper2) = fmul;
native fixed:operator/(fixed:oper1, fixed:oper2) = fdiv;

stock fixed:operator++(fixed:oper)
return oper+fixed(1);

stock fixed:operator--(fixed:oper)
return oper-fixed(1);

stock fixed:operator*(fixed:oper1, oper2)
return _:oper1 * oper2; /* "*" is commutative */

stock fixed:operator/(fixed:oper1, oper2)
return _:oper1 / oper2;

stock fixed:operator/(oper1, fixed:oper2)
return fdiv(fixed(oper1), oper2);

stock fixed:operator+(fixed:oper1, oper2)
return oper1 + fixed(oper2); /* "+" is commutative */

stock fixed:operator-(fixed:oper1, oper2)
return oper1 - fixed(oper2);

stock fixed:operator-(oper1, fixed:oper2)
return fixed(oper1) - oper2;

/* forbidden operations */
forward operator%(fixed:oper1, fixed:oper2);
forward operator%(fixed:oper1, oper2);
forward operator%(oper1, fixed:oper2);





/* Version 1.1 (31.01.2004) */

#if defined _math_included
#endinput
#endif
#define _math_included

#include
#include
#include
#include

#define LGCOUNT 15

stock fixtostr(fixed:fNumber,sNumber[],iMaxLength){
new iNumber,iFrac;
new iSign=1;
new sFrac[4];

if(fNumber<0.000){
iNumber=fround(fNumber,fround_ceil);
}
else{
iNumber=fround(fNumber,fround_floor);
}
iFrac=ffract(fNumber);
if(iFrac<0){
iFrac*=-1;
iSign=-1;
}
numtostr(iFrac,sFrac);
switch(strlen(sFrac)){
case 2:
snprintf(sNumber,iMaxLength,"%d.0%s",iNumber,sFrac );
case 1:
snprintf(sNumber,iMaxLength,"%d.00%s",iNumber,sFra c);
default:
snprintf(sNumber,iMaxLength,"%d.%s",iNumber,sFrac) ;
}
if(iSign==-1 && iNumber==0){
snprintf(sNumber,iMaxLength,"-%s",sNumber);
}
return PLUGIN_CONTINUE;
}

stock fixed:strtofix(sNumber[]){
new fixed:fNumber;

if(strtrim(sNumber,"-",0)>0){
fNumber=fmul(fixedstr(sNumber),-1.000);
}
else{
fNumber=fixedstr(sNumber);
}

return fNumber;
}

stock matherror(iError){
new log_msg[MAX_TEXT_LENGTH];

switch(iError){
case 1:
strcpy(log_msg,"No valid value for function input!",MAX_TEXT_LENGTH);
case 2:
strcpy(log_msg,"Number too high for allowed range!",MAX_TEXT_LENGTH);
case 3:
strcpy(log_msg,"Number too low for allowed range!",MAX_TEXT_LENGTH);
default:
return PLUGIN_CONTINUE;
}
log(log_msg);
return PLUGIN_CONTINUE;
}

stock fixed:f_log10(fixed:fValue,&iError=0){
new fixed:fLG[LGCOUNT]={2147482.000,10000.000,100.000,10.000,3.162,1.778 ,1.334,1.155,1.075,1.037,1.018,1.009,1.005,1.002,1 .000};
new fixed:fLGFract[LGCOUNT-1]={4.000,2.000,1.000,0.500,0.250,0.125,0.063,0.031, 0.016,0.008,0.004,0.002,0.001,0.000};
new fixed:fLocalValue=0.000;
new fixed:fLower=0.000;

if(fValue<=0.000){
iError=1;
return 0.000;
}
if(fValue==2147482.000){
iError=2;
return 6.332;
}
if(fValue==0.001){
return -3.000;
}

for(new i=1;i<4;i++){
if(fValue>=1.000){
break;
}
fValue=fmul(fValue,10.000);
fLower=fLower+1.000;
}

for(new i=0;iif(fValueif(fValue>=fLG[i+1]){
fLocalValue=fLocalValue+fLGFract[i];
fValue=fdiv(fValue,fLG[i+1]);
}
}
else if(fValue==fLG[i]){
break;
}
}
iError=0;

return fLocalValue-fLower;
}

stock fixed:f_ln(fixed:fValue,&iError=0){
new fixed:fFactor=2.303;
new fixed:fCheck;
new fixed:fMultiply;
new fixed:fKeepResult;

fCheck=fValue;

fValue=f_log10(fValue,iError);
if(iError>0){
return fValue;
}

fValue=fmul(fValue,fFactor);
fKeepResult=fValue;
fKeepResult=f_powere(fKeepResult,iError);

if(iError>0){
return fKeepResult;
}

if(fKeepResult==fCheck){
return fValue;
}
if(fKeepResult>fCheck){
fMultiply=-0.001;
}
else if(fKeepResultfMultiply=0.001;
}
for(new i=0;i<1000;i++){
fKeepResult=f_powere(fValue+fmul(fixed(i),fMultipl y),iError);
if(iError>0){
return fKeepResult;
}
if(fKeepResult==fCheck){
return fValue+fmul(fixed(i-1),fMultiply);
}
}

return fValue;
}

stock fixed:f_logab(fixed:fBase,fixed:fValue,&iError=0){

fBase=f_log10(fBase,iError);
if(iError>0){
return fBase;
}
fValue=f_log10(fValue,iError);
if(iError>0){
return fValue;
}

return fdiv(fValue,fBase);
}

stock fixed:f_faculty(fixed:fValue,&iError=0){
new iValue=1;

if(ffract(fValue)==0.000){
if(fValue>0.000){
if(fValue<10.000){
iValue=fround(fValue);
fValue=1.000;
for(new i=2;i<=iValue;i++){
fValue=fmul(fValue,fixed(i));
}
return fValue;
}
iError=2;
return 2147482.000;
}
}
iError=1;

return -1.000;
}

stock fixed:f_powere(fixed:fExponent,&iError=0){
new fixed:fEulerArray[3][10]={{1.000,1.105,1.221,1.350,1.492,1.649,1.822,2.014 ,2.226,2.460},{1.000,1.010,1.020,1.030,1.041,1.051 ,1.062,1.073,1.083,1.094},{1.000,1.001,1.002,1.003 ,1.004,1.005,1.006,1.007,1.008,1.009}};
new fixed:fSignE=1.000;
new fixed:fEuler;
new fixed:fLocalResult=1.000;
new iKeepExponent=0;

fEuler=f_euler();

if(fExponent==0.000){
return 1.000;
}

if(fExponent>14.579){
iError=2;
return 2147482.000;
}

if(fExponent<0.000){
fSignE=-1.000;
fExponent=fExponent*fSignE;
}

iKeepExponent=fround(fExponent,fround_floor);
if(iKeepExponent!=0){
for(new i=0;ifLocalResult=fmul(fEuler,fLocalResult);
}
}

for(new i=0;i<3;i++){
fExponent=fExponent-fixed(iKeepExponent);
fExponent=fmul(fExponent,10.000);
iKeepExponent=fround(fExponent,fround_floor);
fLocalResult=fmul(fLocalResult,fEulerArray[i][iKeepExponent]);
}

if(fSignE==-1.000){
fLocalResult=fdiv(1.000,fLocalResult);
}

return fLocalResult;
}

stock fixed:f_power(fixed:fBasis,fixed:fExponent,&iError =0){
new fixed:fKeepValue;
new iKeep;
new iSign=0;

iKeep=fround(fExponent,fround_floor);

if(fBasis<0.000){
if(fixed(iKeep)!=fExponent){
iError=1;
return -1.000;
}
}

if(fExponent==0.500){
return f_sqrt(fBasis,iError);
}

fKeepValue=fBasis;

if(fixed(iKeep)==fExponent){
if(fExponent<0.000){
fExponent=fmul(fExponent,-1.000);
iKeep=iKeep*-1;
iSign=1;
}
for(new i=1;ifBasis=fmul(fBasis,fKeepValue);
}
if(iSign){
fBasis=fdiv(1.000,fBasis);
}
return fBasis;
}

fKeepValue=f_ln(fKeepValue,iError);
if(iError>0){
return -1.000;
}

return f_powere(fmul(fExponent,fKeepValue),iError);
}

stock fixed:f_euler(){
return 2.718;
}

stock fixed:f_pi(){
return 3.142;
}

stock fixed:f_sqrt(fixed:fNum,&iError=0,fixed:fNumStart= 1.000) {
new fixed:fNum2=fNum;
new fixed:fOne=1.000;

if(f_abs(fNum)!=fNum){
iError=1;
return -1.000;
}

if(fNumStart==fNum2){
fNumStart=1.000;
}

if(fNum<1.000){
fNum2=fdiv(fOne,fNum);
}

for(new i=0;i<100;i++){
fNum2=fdiv(fNum2+fNumStart,2.000);
fNumStart=fdiv(fNum,fNum2);
if(fNum2 <= fNumStart){
break;
}
}

return fNum2;
}

stock fixed:f_abs(fixed:fNum) {
if(fNum >= 0.000) {
return fNum;
}
return fmul(fNum,-1.000);
}

stock fixed:f_max(fixed:fNum,fixed:fNum2){
if(fNum >= fNum2) {
return fNum;
}
return fNum2;
}

stock fixed:f_min(fixed:fNum,fixed:fNum2){
if(fNum < fNum2) {
return fNum;
}
return fNum2;
}

stock distance(x1,x2,y1=0,y2=0,z1=0,z2=0){
new fixed:fNumStart=-1.000;
new fixed:fSum=0.000;
new iDx,iDy,iDz;
new iError=0;

iDx=(x1-x2)*(x1-x2);
iDy=(y1-y2)*(y1-y2);
iDz=(z1-z2)*(z1-z2);

fNumStart=fixed(max(max(iDx,iDy),iDz));
fSum=fixed(iDx+iDy+iDz);
if(fSum==0.000){
return 0;
}

fSum=f_sqrt(fSum,iError,fNumStart);

return fround(fSum);
}

stock fixed:f_sin(fixed:fNum){
new iSign=1;
new fixed:fDummy=0.000;
new fixed:fDummy2=f_pi();

if(fNum<0.000){
fNum=fmul(fNum,-1.000);
iSign=-1;
}

fDummy2=fmul(fDummy2,2.000);
fDummy=fdiv(fNum,fDummy2);
if(fDummy>1.000){
fDummy=fixed(fround(fDummy,fround_floor));
fNum=fNum-fmul(fDummy,fDummy2);
}
fDummy2=f_pi();
if(fNum>fDummy2){
iSign=iSign*-1;
fNum=fNum-fDummy2;
}

fDummy=fNum;
fDummy2=fNum;
for(new i=3;i<=11;i=i+2){
fDummy=fmul(fdiv(fmul(fDummy,fmul(fNum,fNum)),fmul (fixed(i),fixed(i-1))),-1.000);
fDummy2=fDummy2+fDummy;
}

return fmul(fDummy2,fixed(iSign));
}

stock fixed:f_cos(fixed:fNum){
return f_sin(fNum+fdiv(f_pi(),2.000));
}

stock fixed:f_tan(fixed:fNum){
return fdiv(f_sin(fNum),f_cos(fNum));
}

stock fixed:f_cot(fixed:fNum){
return fdiv(f_cos(fNum),f_sin(fNum));
}

/* Calculation of the integral 1/(1+x^2) in order to get the arctan */
stock fixed:f_arctan(fixed:fNum,&iError=0){
new fixed:fDummy;
new fixed:fResult;
new fixed:fRange;
new iNum;

if(fNum>1465.428){
iError=2;
return 2147482.000;
}

if(fNum==0.000){
return 0.000;
}

fDummy=f_abs(fmul(fNum,1000.000));
iNum=fround(fDummy)-1;
fRange=f_max(fNum,0.000);

fResult=fdiv(f_arctan_help(fRange),2.000);

fDummy=fRange+0.001;
for(new i=1;ifResult=fResult+f_arctan_help(fDummy);
fDummy=fDummy+0.001;
}

return fmul(fResult+fdiv(f_arctan_help(fDummy),2.000),fdi v(fNum,fixed(iNum+1)));
}

stock fixed:f_arctan_help(fixed:fNum){
return fdiv(1.000,1.000+fmul(fNum,fNum));
}

stock fixed:f_arcsin(fixed:fNum,&iError=0){

if(fNum>1.000){
iError=2;
return 1.571;
}
if(fNum<-1.000){
iError=3;
return -1.571;
}
if(fNum==1.000){
return 1.571;
}
if(fNum==-1.000){
return -1.571;
}

return f_arctan(fdiv(fNum,f_sqrt(1-fmul(fNum,fNum))));
}

stock fixed:f_arccos(fixed:fNum,&iError=0){

if(fNum>1.000){
iError=2;
return 1.571;
}
if(fNum<-1.000){
iError=3;
return -1.571;
}
if(fNum==1.000){
return 1.571;
}
if(fNum==-1.000){
return -1.571;
}

return fdiv(f_pi(),2.000)-f_arcsin(fNum);
}

stock fixed:f_arccot(fixed:fNum){
return fdiv(f_pi(),2.000)-f_arctan(fNum);
}

stock fixed:f_sinh(fixed:fNum){
return fdiv(f_powere(fNum)-f_powere(fmul(fNum,-1.000)),2.000);
}

stock fixed:f_cosh(fixed:fNum){
return fdiv(f_powere(fNum)+f_powere(fmul(fNum,-1.000)),2.000);
}

stock fixed:f_tanh(fixed:fNum){
return fdiv(f_sinh(fNum),f_cosh(fNum));
}

stock fixed:f_coth(fixed:fNum,&iError=0){
if(fNum==0.000){
iError=1;
return 0.000;
}
return fdiv(f_cosh(fNum),f_sinh(fNum));
}

stock fixed:f_arsinh(fixed:fNum,&iError=0){
if(fNum>1465.428){
iError=2;
return 2147482.000;
}
return f_ln(fNum+f_sqrt(fmul(fNum,fNum)+1.000));
}

stock fixed:f_arcosh(fixed:fNum,&iError=0){
if(fNum>1465.428){
iError=2;
return 2147482.000;
}
if(fNum<1.000){
iError=3;
return 0.000;
}
return f_ln(fNum+f_sqrt(fmul(fNum,fNum)-1.000));
}

stock fixed:f_artanh(fixed:fNum,&iError=0){
if(fNum>=1.000){
iError=2;
return 0.000;
}
if(fNum<=-1.000){
iError=3;
return 0.000;
}
return fdiv(f_ln(fdiv(1.000+fNum,1.000-fNum)),2.000);
}

stock fixed:f_arcoth(fixed:fNum,&iError=0){
if(fNum<=1.000){
if(fNum>=-1.000){
iError=1;
return 0.000;
}
}
return fdiv(f_ln(fdiv(1.000+fNum,fNum-1.000)),2.000);
}

stock fixed:f_degtorad(fixed:fNum){
return fmul(fdiv(fNum,180.000),f_pi());
}

stock fixed:f_radtodeg(fixed:fNum){
return fdiv(fmul(180.000,fNum),f_pi());
}
